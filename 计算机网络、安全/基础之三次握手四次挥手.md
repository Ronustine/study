# 三次握手、四次挥手

[TOC]

## 三次握手

> 三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器**总共发送3个包**。目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息

1. （第一次）建立连接前需要server端先监听端口，因此server端简历连接前的初始状态为LISTEN状态，这时client端准备建立连接，先发送一个**连接请求报文段**`SYN=1  seq=x`，发送完后，client端的链接状态变成了`SYN_SENT`状态；
2. （第二次）server段收到请求报文段后，同意建立连接，则会向client端发送**确认报文段**`SYN=1 ACK=1 ack=x+1 seq=y`，这时，server连接进入`SYN_RCVD`状态；
3. （第三次）client收到server的确认后还需要给server端**给出确认**，**确认报文段**`ACK=1 ack=y+1 seq=x+1`，此时client端的连接状态就变成了`ESTABLISHED`状态；
4. server端收到client端的确认后，server端的连接状态也就进入了`ESTABLISHED`状态，此时建立连接完成。

注意：第三点中，为何client需要再次发送确认，如果缺失这一步，就无法防止**已失效的连接请求报文**突然又传送到了server端。
例如client发送了两次建立连接的请求，第一次由于网络节点长时间滞留，进而发起第二次（或者更多）连接，并且成功与server建立、交互、断开。而此时第一次的请求滞留到现在，则server端会误以为又要建立新的连接，那就会向client端发送确认，但client并没有发出建立连接的请求故而不会理睬，而server端单方面却建立了连接，并一直等待，此时会浪费大量资源。

### 了解一下SYN攻击（典型的DDOS攻击）

>在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect)。此时服务器处于SYN_RECV状态。当收到ACK后，服务器转入ESTABLISHED状态。

Syn攻击就是攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
检测SYN攻击非常的方便，当在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在Linux下可以如下命令检测是否被Syn攻击：`netstat -n -p TCP | grep SYN_RECV`
一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术（看起来好用些）、增加最大半连接和缩短超时时间等。
但是不能完全防范syn攻击。

## 四次挥手

> 连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

1. A向TCP**连接释放报文**`FIN=1 seq=u`，这时A进入`FIN-WAIT-1`状态，等待B确认；
2. B收到报文即发出确认`ACK=1 ack=u+1 seq=v`，这时B进入`CLOSE-WAIT`状态，此时从A到B的方向的连接就释放了，A进入`FIN-WAIT-2`状态，TCP处于半关闭状态（half-close）状态（此时B依旧可以发送数据，A仍要接收）；
3. 若B没有要向A发送的数据，其应用进程就通知TCP释放连接报文`FIN=1 seq=w ack=u+1`，这时B就进入`LAST-ACK`状态，等待A确认；
4. A收到后必须发出确认报文`ACK=1 ack=w+1 seq=u+1`，然后进入`TIME-WAIT`，需要在**时间等待计时器**设置的2MSL后才进入`CLOSED`，B收到后则进入`closed`状态；

注意：第四步的2MSL是保证A向B确认时出现网络问题，B无法接收，这时B会重发释放报文，A就能在这个时间内收到（A的时间等待计时器会重新启动）。这样可以保证B按步骤进入`CLOSED`。而且，可以在经过2MSL，使本连接持续的时间内所产生的报文段在网络中消失。
