
# 目录

[TOC]

> 模型是一种简化，抽象出解决问题密切相关的方面，忽略细节。
> 两个要素：模型要支持有效的实现、抽象出关键的领域知识。
> 用户应用软件的问题区域就是软件的领域。

> 模型的作用
> 1. 模型和设计的核心相互影响（相互牵制，避免天马行空的想法、需求。相互促进，有意义的扩展）
> 2. 模型是团队所有成员使用的通用语言的中枢（增加有效沟通。减少信息传递造成的信息丢失）
> 3. 模型是浓缩的知识（确保领域对于每个人的理解是一致的）

**辨识分析模型**（这是不对的）：完全脱离于程序设计，它是对业务领域分析的结果，在组织业务领域的概念时，完全不去考虑自己在软件系统起到的作用。仅仅作为理解工具。编码开始后，开发人员不得不重新对设计进行抽象，大量的领域知识就会被丢弃。

## 消化知识
> - 不仅仅是名词，业务活动和规则都是核心
> - 将设计映射到模型上。找到一组适用于所有细节的抽象概念。
> - 需要开发人员引导，与领域专家进行协作
> - 模型建立完成后就可以作为重构的依据了

#### 有效的建模
1. 模型和实现的绑定（作用1）
2. 建立了基于模型的语言（作用2）
3. 开发一个蕴含丰富知识的模型（作用3）
4. 提炼模型（可演化）
5. 头脑风暴和实验（可演化）

#### 知识消化
1. 传统的瀑布流方法中，知识是朝一个方向流动，且不会积累
2. 迭代过程中，没有建立知识体系，程序员只为了添加功能，不重构，项目也不会从原有特性自然的扩展出强大的新特新。

影响：
- 开发人员 领域模型的精化迫使他们学习重要的业务原理，不是机械地进行功能开发
- 领域专家 迫使他们提炼自己已知道的重要知识，并完善自身的理解，接触到软件项目所必须的概念严谨性

#### 持续学习
> 模型要演化。但也会丢失。
> 现状：
> - 项目知识零散分散在人与文档中，噪音多
> - 团队人员会流动，团队会重组
> - 代码会外包，知识不回传

团队必须有意识地高效积累，持续学习

#### 知识丰富的设计
> 模型不仅是“发现名词”。业务活动和规则如同实体一样，是领域的核心

提取隐藏的概念：
业务的简单限制，比如返回的学生成绩列表需计算平均分，这很容易**被当成简单的计算**，并散布在各处。实际上这是一条重要的业务规则，我们需要考虑如何清晰的表达出来，让团队的所有人都能了解到。
注意：这个只是简单而重要的规则，如果在业务的快速迭代发展的过程中，规则逐渐变得复杂，那么修改规则将变得越来越棘手。

如何捕获这种隐藏概念并表达，在后面展示。

#### 深层模型
模型一定是不断发展的，最初始的模型只停留在表面，随着对领域理解的加深，需要对原模型进行改造。相应的代码也开始重构。

## 交流与语言的使用
> 模型是一组得自于项目人员头脑中的概念，反映了领域深层含义的术语和关系。虽然语言是为领域量身定制的，单就技术开发而言，其依然足够精确。将模型与开发活动结合在一起，使模型与代码紧密绑定。

#### 模式：UBIQUITOUS LANGUAGE
> 核心是统一对概念的理解，简化并保证团队人员的精确沟通。
> 团队使用共通的语言才能创建出灵活、蕴含丰富知识的设计。

- 不同模型和语言如何共存，如何防止分裂？
- 作用：将整个系统组织成一个大尺度结构（**大型结构**），定义不同系统和模型之间关系的**限界上下文**

显然，领域专家用其自己的语言来模糊地描述需求，开发人员再形成一个模糊的认知。这是极不安全的做法。两边的人要是负责任还好，可以靠保持沟通减少偏差，但要是随意解释、理解，那就是灾难。就算两边的人负责，但是没有知识的积累、沉淀，知识的丢失也是不可忽视的损失。

在相互沟通过程中，可以立马暴露出所使用的概念的缺点。可以进行完善领域，并反映到代码中。

**结论**：将模型作为语言的支柱。确保团队在内部的所有交流以及代码中坚持使用这种语言，在画图、写东西、表述时都使用这种语言。通过尝试不用的表示方法（它们反映了备选模型）来消除难点。然后重构代码，重命名类、方法和模块，以便与新模型保持一致。解决交谈中的术语混淆问题，像我们对普通词汇形成一致的理解一样。**要认识到：UBIQUITOUS LANGUAGE的更改就是对模型的更改**。
领域专家应该抵制不合适或无法充分表达领域理解的术语或结构，开发人员应该密切关注会妨碍设计的有歧义和不一致的地方。

#### 大声建模
> 改善模型的最佳方式之一就是通过对话来研究，说出可能的模型变化中的各种结构，这样不完善的地方很容易被听出来。
> 使用单词和短语是极为重要的（我们头脑有极强的抽象能力），其将我们的语言能力用于建模工作。

可以回想石器时代，自己的前人是如何摸索，才得出我们现在用于交流的语言。
可以回想俗语，为什么仅一个词：草船借箭、空城计，脑海里就能构建出复杂的画面和故事。
可以回想网络用语，为什么我们知道GG，MM，886，然并卵，十动然拒是什么意思。

**结论**：讨论系统要结合模型，使用模型元素及其交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的想法应用到图和代码中。

#### 一个团队，一种语言
> 模型的定位是领域专家和开发的桥梁，不能认为是单方面的建立。单方面的建立一定是想当然的，不准确的。

领域专家、开发人员使用模型来进行走查，从而对模型进行非正式的测试，每次讨论都是使用模型的机会，可以加深理解，精化概念。

作用：
- 领域庄稼可以使用模型语言编写用例，甚至说明验收测试
- 使用精化后的UBIQUIOUS LANGUAGE来重组需求

#### 文档和图
> 简单、非正式的UML图可以维系整个讨论
> 模型不是图
> 文档最大价值在于解释模型的概念

UML并不贴切，不能表示模型所表示的概念的意义；不能表示对象应该做哪些事。涵盖整个对象的综合性大图会失去沟通和解释能力，把人淹没在大量的细节中。

书面设计文档 
- 作为代码精确性和细节，口头交流的补充。不应再重复表示代码已经明确表达出的内容
- 文档应当鲜活并保持最新
- 文档深入到各个项目活动中去

**什么是完全依赖可执行代码**
一段代码产生的实际行为是不会改变的，但是方法名称可能会有歧义，会产生误导或者因为已经过时而无法表示本方法的本质含义。测试的断言是严格的，但变量和代码组织方式所表达的意思未必严格。好的编程风格会尽力使这种联系直接化。
消除这些差异是诸如声明式设计这样方法的最大优点，这类方法中，程序元素用途的陈述决定了它在程序中的实际行为。从UML生成程序的部分动机就来源于此，虽然目前看来通常不会得到好的结果。
尽管代码肯能会产生误导，但它仍然比其他文档更基础。要想利用当前的标识技术使代码所传达的消息于他的行为和意图保持一致，需要纪律和思考设计的特定方式。有效的交流，代码必须基于在编写需求时所使用的同一种语言。

#### 解释性模型
> 核心：在实现、设计和团队交流中使用同一个模型作为基础。

解释性模型：
可以使用与软件设计无关的其他种类模型的图片或文字。可以包含哪些提供上下文的领域方面——这些上下文用于澄清范围更窄的模型，有一定的自由度。
不必是对象模型，最好不是。实际上在这些模型中不实用UML是有好处的，可以避免人们错误认为这些模型与软件设计是一致的。尽管解释性模型与驱动设计的模型往往有对应关系，但不完全类似。

比如：
画出来的UML类图没人懂，就可以画图，能表达意思即可。

## 绑定模型和实现
> 简单的模型才容易使用，才能谈绑定

#### 模式：MODEL-DRIVEN-DESIGN
> 寻求一种能够满足分析模型和程序设计两方面的单一模型

好处： 严格按照基础模型来编写代码，能够使代码更好表达设计含义，并且使模型与实际的系统相契合。

- 模型若被遗忘，与项目渐行渐远，起误导作用。
- 整个程序设计或者核心部分没有与领域模型相应，那么这个模型就没有价值，软件的正确性也要被怀疑。同时，模型和设计功能之间过于复杂的对应关系也是难于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析和设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享。

**结论**：
1. 软件系统各个部分的设计应该忠实反映领域模型，以便体现出二者之间的明确对应关系。我们应该反复检查并修改模型，让软件可以更加自然的实现模型，即使想让模型反映出更深层次的领域概念时也应如此。我们需要的模型不但应该满足这两种需求，还应该能够支持健壮的UBIQUITOUS LANGUAGE。
2. 从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要波及接下来相应的项目活动。
3. 完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象的编程。

代码有效的描述模型，就需要用到程序设计和实现的技巧
知识消化人员研究模型各个选项，并细化为实用的软件元素。

#### 建模范式和工具支持
> 为了使MODEL-DRIVEN-DESIGN发挥作用，一定要在可控范围内严格保证模型与设计之间的一致性。要由软件工具支持的建模范式，他可以在程序中之间创建模型中对应概念。（面向对象就是基于建模范式的）
> Prolog是基于逻辑的，非常适合。因为模型是一组逻辑规则以及这些规则所操作的事实。

面向对象与建模的天然契合：对象真实存在于内存中，它们与其他对象相互联系，它们被组织成类，并且通过消息传递来完成相应的行为。得益于对象的技术能力——用其组织程序代码，只有用代码表达模型概念时，对象设计的真正突破之处才彰显出来。

#### 为什么模型对用户至关重要
> 让用户了解模型，可以挖掘软件的潜能，可以使软件的行为合乎清理、前后一致

一对不同的模型：用户模型和 设计/实现模型
大多数情况下，未经过处理的领域模型视图肯定不便与用户使用。但是在用户界面中出现与领域模型不同的影像将会使用户产生迷惑。
如 Windows IE的收藏夹，实际上是包含URL的文件，并将文件名称存储在收藏夹列表中。问题是网页标题含有Windows系统文件名不能接受的非法字符串，就会出现错误，报：文件名不能包含下列任何字符串：\/:*?<>|。用户会迷惑，或者不报错，直接去掉非法字符。这绝不是用户期望的。
所以，应该将事实表现出来，用户可以利用自己所知的文件系统知识更好的使用收藏夹。

#### 模式：HANDS-ON MODELER
> （亲身实践的建模者）建模和实现两个过程不能分离开：经验丰富的工程师只做设计，水平较低的组装产品，这是不对的。设计完还需要一起参与代码开发，组装产品时需要反馈模型的问题

- 模型的一些意图在其传递过程中丢失了。模型的整体效果受细节的影响很大。
- 模型与程序实现及技术互相影响

如果编写代码的人不想对模型负责，或者不知道怎么让程序对应上模型，那么绑定是失败的。而且如果没有意识到改变代码就意味着改变模型，那么重构将会消弱模型。前面已经提到瀑布流式的流转会造成信息丢失。

**结论**：建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。代码编写人员必须学会用代码来表达模型。双方要有协作的习惯，有意识的通过UBIQUITOUS LANGUAGE交流。不要将建模和编程过程完全分离。