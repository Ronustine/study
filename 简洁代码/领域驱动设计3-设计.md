
# 目录

[TOC]

> 细微的模型差别和设计决策是如何影响领域驱动设计过程的。
> 将领域设计与软件系统中的其他关注点分离会使设计与模型之间的关系非常清晰。根据不同的特征来定义模型元素则会使元素的意义更加鲜明。

本部分的模式以及关联的方式

![1](DDD-1.jpeg)

## 1. 分离领域
> **将领域实现独立出来是领域驱动设计的前提**
> 解决领域问题占软件系统很小一部分，但是非常重要。我们要着眼于模型中的元素，并将他们视为一个系统。将领域对象与系统中的其他功能进行分离，避免将领域概念和其他只与软件技术相关概念混淆。

#### 1.1 模式：LAYERED ARCHITECTURE
![2](DDD-2.JPG)
> **将领域层分离出来才是实现MODEL-DRIVEN DESIGN的关键**
> 要创建出能够处理复杂任务的程序，需要做到关注点分离——使设计的每个部分都得到单独的关注。分离的同时要维持系统内部复杂的交互关系。

状况：在业务对象中直接写入用户界面、数据库访问等支持代码，业务逻辑则会被嵌入到用户界面组建和数据库脚本中。只是为了以简单的方式在短期内完成开发工作。
如果与领域有关的代码分散在各处，那么查看和分析领域代码则会异常困难。在用户界面简单修改很可能会改变业务逻辑，调整业务规则也可能需要对用户界面代码、数据库操作或者其他的程序元素进行仔细的筛查。这样就不太可能实现一致的、模型驱动的对象了，同时也会给自动化测试带来困难。

大多数如下的分层
| 层 | 说明 |
|--|--|
| 用户界面层 | 负责向用户显示信息和解释用户指令。这里值得用户可以使另一个计算机系统 |
| 应用层 | 定义软件要完成的任务，并且只会表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道 /n  应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使他们相互协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度 |
| 领域层（模型层） | 负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节使基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。**领域层使业务软件的核心** |
| 基础设施层 | 为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面绘制屏幕组建等。基础设施层还能够通过架构框架来支持4个层次间的交互模式 |

**结论**
在复杂的应用程序划分层次。每一层内分别设计，使其具有内聚性并且只依赖于他的下层。采用标识的架构模式，只与上层进行松散的耦合。将所有与领域模型相关的代码放在一个层中，并与其他层的代码分开。领域对象应该将重点放在如何表达领域模型上，不需要考虑自己的显示和存储问题，无需惯例应用任务等内容。使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用。

其他
1. Smalltalk语言发明的一种模式MODEL-VIEW-CONTROLLER(MVC)；
2. Fowler讨论了这种模式以及相关变体；
3. Larman在MODEL-VIEW SEPARATION模式有提到；（APPLICATION COORDINATOR是连接应用层的一种方法）

###### 1.1.1 将各层关联起来
> 分层好了，各层怎么联系

各层之间是松散的，层与层之间的依赖关系是**单向**的，上层可以之间使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用。如果下层元素需要与上层元素通信，则需要采用另一种通信机制，使用架构模式来连接上下层，如回调模式或者OBSERVERS模式。
只要连接方式能够维持领域层的独立性，保证在设计领域对象时不需要同时考虑可能与其交互的用户界面，那么这些连接方式都是可用的。

###### 1.1.2 架构框架
> 好的框架既能解决复杂技术问题，也能让领域开发人员集中精力去表达模型，而不考虑其他问题
> 使用框架的目的：建立一种可以表达领域模型的实现并且用它来解决重要问题。

如果一个架构能够把那些与领域相关的代码隔离出来，得到一个内聚的领域设计，同时又使领域与系统其他部分保持松散耦合，那么这种架构也许可以支持领域驱动设计。

1. 框架需要满足领域层的需求，即使意味着抛弃框架的一些功能
2. 审慎地选择框架中最具价值的功能能减少程序实现和框架之间的耦合，使随后的设计决策更加灵活

#### 1.2 领域层是模型的精髓
领域层是领域模型以及所有与其直接相关的设计元素的表现，由业务逻辑的设计和实现组成，在MODEL-DRIVEN DESIGN中，领域层的软件构造反映了模型的概念。

#### 1.3 模式：THE SMART UI “反模式”
> 帮助认清为什么、何时采用分离模型来分离出领域层
项目只需要简单的功能，以数据输入和显示为主，涉及业务规则很少；团队经验不多；时间少。
在用户界面实现所有的业务逻辑。将应用程序分成小的功能模块，分别将他们实现成用户界面，并嵌入业务规则。用关系数据库作为共享的数据存储库。使用自动化程度最高的用户界面创建工具和可用的可视化编程工具。

使用了这个模式，除非重写，否则不能改用其他的设计方法。

同样的，采用MODEL-DRIVEN DESIGN的项目团队从项目初始就应该采用模型驱动的设计。当然，即使是经验丰富的项目团队在开发大型软件系统，也不得不从简单的功能着手，然后在整个开发过程中使用连续的迭代开发。但最初试探性的工作应该是由模型驱动的，而且要分离出独立的领域层，否则项目进行到后面就变成THE SMART UI了

#### 1.4 其他分离方式
状况：考虑那些没有完全集成到模型中的领域元素、与同一领域中使用不同模型的其他开发团队合作。
参见BOUNDED CONTEXT和ANTICORRUPTION LAYER。
领域层内进行进一步区分，从次要细节凸显出领域的核心概念。

## 2 软件中所表示的模型
> 从细节出发，讨论基本模型元素。将模型与实现的各个细节联系起来，实现同时演进。
> 区分表示模型的3中模型元素模型：ENTITY、VALUE OBJECT、SERVICE。

>  难点：定义用来捕获领域概念的对象很容易，但要想反映其含义却很困难。我们将着重区分各种模型元素的含义，与设计时间结合起来

> 概要：
> 1. 一个对象是用来表示某种具有连续性和标识的事物，还是描述某种状态的属性呢？这是ENTITY与VALUE OBJECT之间的根本区别。领域中还有一些是适合动作或操作来表示，这比对象更清楚，最好用SERVICE来表示。SERVICE是应用客户端来完成某事，技术层有很多，在领域层也能使用，当对软件要做的某项无状态的活动时，就可以将这活动作为SERVICE；
> 2. 在一些情况下，不得不对对象模型进行折中的变更，会影响模型纯度，给出一些原则，确保正确的方向；
> 3. MODULE，每个设计决策都应该时深入理解领域中的某些深层知识之后做出的。高内聚，低耦合可以适应到概念本身；
> 4. 将这些体现模型的构造块组织在一起，并将这些思想组织到模型驱动开发的上下文中，可以创建符合领域驱动设计主要原的组件，有助于解决更大的模型和设计问题；

#### 2.1 联系
> 对象之间的关联使得建模与实现之间的交互更为复杂
> **模型中每个可遍历的关联，软件中都要有同样属性的机制**
> 尽可能对关系进行约束（减少联系）

简化联系：
生活中有大量的“多对多”关联，很多关联天生就是双向的。这些关联会导致实现和维护变得复杂，需要把握一些原则
1. 规定一个遍历方向；
2. 添加限定符，以便减少多重关联；
3. 消除不必要的关联；

双向关联：双向意味着两个对象放在一起考虑才能理解。当应用程序不要求双向遍历，可以指定一个方向，减少相互依赖，简化设计。**理解领域后可以自然推断出这种方向，坚持将关联限定为领域所倾向的方向，还能突出剩余双向关联的重要性**。

如：美国有很多总统，在提到“乔治·华盛顿”却很少问是哪个国家的。从实用角度看，关系可以简化到国家到总统的但想关联，更为深入的，可以带上时间（一个国家在一个时间段只有一个总统，可以化成1对1的关联）

#### 2.2 模式：ENTITY(REFERENCE OBJECT)
> 对象不是通过属性定义的，而是通过连续性和标识定义的。
> 主要由标识定义的对象被称作ENTITY。
> 满足两个条件：在生命周期中具有连续性；他的区别不是由那些对用户非常重要的属性决定的。
> ENTITY有特殊的建模和设计思路。具有生命周期，期间他们的形式和内容可能发生根本改变，但必须保持一种内在的连续性。

对象模型可能把我们的注意力引到对象的属性上，但实体的基本概念是一种贯穿整个生命周期（或多种形式）的抽象的连续性。一些对象主要不是由他们属性定义的。实际上表示了一条“表示线”，这条线跨越时间，常常经历多种不同的表示。

注意：
1. 即使对于不发生根本变化或者生命周期不太复杂的ENTITY，也应该在语义上把它们作为ENTITY来对待，这样可以得到更清晰的模型和更健壮的实现；
2. 面向对象语言在每个对象中都构建了一些与“标识”有关的操作（内存地址），在应用领域没太大意义；
3. 当一个对象由标识区分时，那么在模型中应该主要通过标识来确定该对象的定义，使定义变得简单，并集中关注生命周期的连续性和标识。定义标识操作时，要确保这种操作为每个对象生成唯一的结果，可以附加一个保证唯一性的符号来实现（数据库主键），**模型必须定义出“符合什么条件才算是相同的事物”**；

###### 2.2.1 ENTITY建模
1. 考虑属性；
2. 最基本的是确保连续性；
3. 保持实体简练，抓住对象定义的最基本特征，尤其是识别、查找或匹配对象的特征；
4. 将行为和属性转移到与核心实体关联的其他对象（可能是ENTITY、VALUE OBJECT）中；
5. 实体往往通过协调关联对象的操作来完成自己的职责；

###### 2.2.2 设计标识操作
1. 每个ENTITY都必须有一种建立标识的操作方式，以便与其他对象区分开；
2. 有些数据属性或者属性组合可以确保他们在系统中的唯一性，或者在属性上加简单约束；
3. 当对象属性没法形成真正唯一键时，为每个实例附加一个在类中唯一的符号，一旦这个ID被创建并存储为ENTITY的属性，必须指定为不可变的。这个ID是系统自动生成的，且算法必须确保ID是唯一的；
4. 跟踪ENTITY的标识是非常重要的，但为其他对象加上标识会影响系统性能并增加分析工作，而且使模型变得混乱，因为所有对象看起来都是相同的；

#### 2.3 模式：VALUE OBJECT
> 很多对象没有概念上的标识，他们描述了一个事务的某种特征。
> 用于描述领域的某个方面而本身没有概念标识的对象称为VALUE OBJECT（值对象）。
> 只关心他们是什么，不关心是谁。

- VALUE OBJECT可以是字符串和数字
- VALUE OBJECT可以是其他对象的集合
- VALUE OBJECT可以引用ENTITY
- 作为参数在对象之间传递消息，常常是临时对象
- VALUE OBJECT用作ENTITY的属性
- VALUE OBJECT是不可变的，不要分配任何标识，不要设计成ENTITY那么复杂

关心一个模型元素的属性时，应归类为VALUE OBJECT。我们要使这个模型元素能够表示出属性的意义，并为他提供相关功能。

###### 2.3.1 设计VALUE OBJECT
1. 不关心使用的是VALUE OBJECT哪个实例。在设计时可以多种选择：复制、共享或保持VALUE OBJECT不变；
2. 注意：多个ENTITY共享同一个VALUE OBJECT对象，会出现修改一处（即对象逸出）。影响到其他ENTITY的情况(FLYWEIGHT模式 是相对的)；
3. 复制和共享哪个好，取决于实现环境。复制可能导致大量对象，共享会减慢分布式系统；

采用共享的情况：
1. 节省数据库空间或减少对象数量是一个关键要求时；
2. 通信开销很低时（如在中央服务器中）；
3. 共享的对象被严格限定为不可变时；

VALUE OBJECT不可变时，变更管理就会很简单，因为除了整体替换之外没有其他改变。可以确保共享和引用传递的安全性。可以根据技术需求来决定时使用复制还是共享，因为没有后顾之忧——应用程序不依赖于对象的特殊实例。

出于性能考虑，何时允许可变：
1. VALUE 频繁改变；
2. 创建和删除对象开销很大；
3. 替换（不是修改）打乱集群；
4. VALUE 共享不多，或者共享不会提高集群性能，或其他某种技术原因；

**注意**：VALUE实现是可变的，那就不能共享它。不论是否共享VALUE OBJECT，在可能的情况下都设计为不可变。
