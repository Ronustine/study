
# 目录

[TOC]

> 随着系统增长，会变得越来越复杂，当我们无法通过分析对象来理解系统的时候，就需要掌握一些操控和理解大模型的技术了。这部分的决策都需要由团队来制定，甚至需要多个团队共同协商制定。这些决策往往是把设计和策略综合到一起的结果。
> 负有雄心的企业总是想实现一个涵盖所有业务，紧密集成的系统。但几乎所有这种规模的组织中，整体业务模型太大也太复杂了，难以管理，甚至难以作为一个整体来理解。我们需要在概念和实现上把系统分解为较小的部分，应该如何保证实现这种模块化的同时，不失去集成所具备的好处。从而使系统的不同部分能够进行互操作，以便协调各种业务操作。

如果设计一个把所有概念都涵盖进来的单一领域模型，又会非常笨拙，而且会出现大量难以察觉的重复和矛盾；
如果用临时拼凑的接口把一组小的、各自不同的子系统集成到一起，有不具备解决企业级问题的能力，并且每个集成点上都有可能出现不一致。
通过采用系统的、不断演变的设计策略，就可以避免这两种极端问题。

在这种规模的系统中采用领域驱动设计方法，也不要脱离实现去开发模型，每个决策都必须对系统开发产生直接的影响，否则就是无关的决策。战略设计原则必须指导设计决策，以减少各个部分之间的相互依赖，在使设计意图更为清晰的同时而又不失去关键的互操作性和协同性。战略设计原则必须把模型的重点放在捕获系统的概念核心，也就是系统的“远景”上。而且在完成这些目标的同时又不能为项目带来麻烦。我们探索三个主题：上下文、精炼、大型结构。

- 上下文使我们在不同的部分中进行工作，而不会破坏模型或是无意间导致模型的分裂；
- 精炼能够帮助我们理解各个部分之间的复杂关系，同时保持整体视图的清晰；
- 大型结构感能够保持各个不同部分之间的一致性，有助于这些部分的集成；

**上下文**
最根本的一个原则。成功的模型必须逻辑自洽。要把不同来源的子系统或者应用程序隐含的模型统一起来要求太高了。通过为每一个模型定义一个BOUNDED CONTEXT，然后在必要的情况下定义它与其他上下文的关系，建模人员就可以避免模型变得纠缠不清。

**精炼**
可以减少混乱，把注意力集中到正确的地方。主次分明。整体领域模型需要突出系统中最有价值和最特殊的那方面，在构造领域模型应该尽可能把注意力集中在这部分上，使系统不会偏离预期方向。战略精炼可以使大的模型保持清晰。有了更清晰的视图后，CORE DOMAIN的设计就会发挥更大作用。

**大型结构**
用来描述整个系统的。如果不贯彻某个主旨来应用一些系统级的设计元素和模式的话，关系仍然可能非常混乱。

上面三种原则各有各的用处，结合起来使用发挥更大的力量，遵守这些原则就可以创建出好的设计，即使是对一个非常庞大的没有人能够完全理解的系统也是如此。

## 1 保持模型的完整性
场景：两个团队在对同一个模型修改。实际上两个团队用的是不同的模型，他们都对模型做了一些假设，使之能够在自己的上下文中使用。当两个团队被组合到一起而没有消除矛盾时，结果就产生了不可靠的软件。

明确边界，各模型只在各自边界内使用。模型的基本要求是保持内部的一致性（统一）。每个术语都不会有模凌两可的意义，也不会有规则冲突。除非模型在逻辑上是一致的。否则就没有意义。
理想情况下，我们可以得到涵盖整个企业领域的单一模型，但实际上大型系统开发并非如此理想。在整个企业系统中保持这种水平统一是得不偿失的。在系统的各个不同部分中开发多个模型是很有必要的，**但我们必须慎重地选择系统的哪些部分可以分开，以及他们之间是什么关系。** 我们需要用一些方法来保持模型关键部分的统一。大型系统领域模型的完全统一既不可行，也不划算。

通常，多个模型会限制集成，并且使沟通变得麻烦，看起来也不够雅致。对多个模型的抵制有可能会导致另一种尝试——将大型项目中所有软件统一到单一模型中。一定要考虑风险：
1. 一次尝试对遗留系统做过多的替换；
2. 大项目可能会陷入困境，因为协调的开销太大，超出了这些项目的能力范围；
3. 具有特殊需求的应用程序可能不得不使用无法充分满足需求的模型，而只能将这些无法满足的行为放到其他地方；
4. 另一方面，试图用一个模型来满足所有人的需求可能会导致模型中包含过于复杂的选择，而很难使用；
这还只是从技术角度来看待问题，权力上的划分和管理级别的不同也可能要求把模型分开，而且不同模型的出现也可能是团队组织和开发过程导致的结果。因此，即使完全的集成没有来自技术方面的阻力，项目也可能会面临多个模型。

既然不能维护一个涵盖整个企业的统一模型，那就不要再受到这种思路的限制。通过预先决定什么应该统一，并认识到什么不能统一，我们就能创建一个清晰的，共同的视图。保证需要统一的部分保持一致，不需要统一的部分不会引起混乱或破坏模型。

本章解释用于识别、沟通和选择模型边界及关系的技术。BOUNDED CONTEXT（限界上下文）定义了每个模型的应用范围，CONTEXG MAP(上下文图)给出项目上下文及他们之间关系的总体视图。这些都可以降低模糊性的技术。确立了CONTEXT边界之后，仍然需要CONTINUOUS INTEGRATION（持续集成），使得模型保持统一。在这稳定基础之上，可以开始实施在界定和关联CONTEXT方面更有效的策略了——从通过SHARED KERNEL（共享内核）来紧密关联上下文，到那些SEPARATE WAYS（各行其道）地进行松耦合的模型。

![1](DDD-10.jpeg "各个模型的关系图")

#### 1.1 模式：BOUNDED CONTEXT
任何大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现BUG，变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用。
一个模型只在一个上下文中使用。这个上下文可以是代码的一个特定部分，也可以是某个特定团队的工作。

**结论**
明确地定义模型所应用的上下文。根据团队的组织、软件系统的各个部分的用法以及无力表现（代码和数据库模式等）来设置模型的边界。在这些边界中严格保持模型的一致性，而不要受到边界之外问题的干扰和混淆。

BOUNDED CONTEXT明确地限定了模型的应用范围，以便让团队成员对什么应该保持一致以及上下文之间如何关联有一个明确和共同的理解。在CONTEXT中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况。通过划定明确的边界，可保持模型纯粹，因而在它所适用的CONTEXT中更有效。同时，也避免了将注意力切换到其他CONTEXT时引起的混淆。

**区分BOUNDED CONTEXT与MODULE**
？？？

新旧模型之间的必要转换由原有系统团队处理。转换机制不是由新模型驱动的。因此它不在BOUNDED CONTEXT中，实际是边界本身的一部分，这一点在CONTEXT MAP讨论

**识别BOUNDED CONTEXT中的不一致**
最明显的是已编码的接口不匹配。采用了自动测试的CONTINUOUS INTERGRATION可以捕捉这类问题。**但是，语言上的混乱往往是一种早期的警告信号**。

注意：不同模型的元素组合到一起可能会引发两类问题：**重复的概念、假同源**。
1. 重复的概念是指两个模型元素实际上表示同一个概念，明显的感觉是这个概念的信息发生变化时，必须同时更新两个地方，每次新知识导致一个对象被修改时，必须重新分析和修改另一个对象。
2. 危害更大，是指对不一样的概念使用了相同的术语的两个人认为是谈论同一个事情。当两个定义都与同一个领域方面有关，而只是概念上稍有区别，这种冲突更难实现。

发现不一致要尽快解决。可能将模型重新合成整体，预防分裂。也可能独立开来。可以参考下一节

#### 1.2 模式：CONTINUOUS INTEGRATION
> 把一个上下文中的所有工作足够频繁的合并到一起，并使他们保持一致，当模型发生分裂时，可以迅速发现并纠正问题。有两个级别的操作：模型概念的集成、实现的集成。
> **范围**：只有在BOUNDED CONTEXT中才是重要的。

问题：
当很多人在**同一个BOUNDED CONTEXT中工作**时，模型很容易发生分裂。即使是3～4人团队也有可能遇到严重问题。然而，将系统分解为更小的CONTEXT，最终又难以保持集成度和一致性。

具体表现：
- 没有理解其他人创建的对象或者交互意图就修改，使其失去了原来的作用；
- 没意识到正在开发的概念已经在模型的另一个部分实现了，导致重复；
- 担心破坏现有功能而不去改动，重新开发；

在持续集成时，团队成员之间通过经常沟通来保证概念的集成。团队必须对不断变化的模型形成共同的理解。基本方法是对UBIQUITOUS LANGUAGE多加锤炼，同时，实际工件通过系统性的合并\构建\测试过程来集成，可以尽早暴露模型的分裂问题。

用来集成的过程很多，有效的过程都具备以下特征：
- （最根本）**概念集成**，讨论模型和应用程序时要坚持使用UBIQUITOUS LANGUAGE；
- 分步集成，采用可重现的合并\构建技术；
- 自动测试套件；
- 有一些规则，用来为尚未集成的改动设置一个想当小的生命期上限；

在MODEL-DRIVEN-DESIGN中，概念集成为实现集成铺平了道路，而实现集成验证了模型的有效性和一致性，并暴露模型的分裂问题。

**结论**
建立一个把所有代码和其他实现工件频繁地合并到一起的过程，并通过自动化测试来快速查明模型的分裂问题。严格坚持使用UBIQUITOUS LANGUAGE，以便在不同人的头脑中演变出不同的概念时，使所有人对模型都能达成一个共识。

#### 1.3 模型：CONTEXT MAP
只有一个BOUNDED CONTEXT并不能提供全局视图。其他模型的上下文仍不清楚而且还在不断变化。定义不同上下文之间的关系，在项目中创建一个所有模型上下文的全局视图。CONTEXT MAP位于项目管理和软件设计的重叠部分。无需拘泥特定的文档格式，重在人员之间共享并理解。

问题：
当其他团队的人员并不清楚CONTEXT的边界，会不知不觉地作出一些更改，从而使边界变得模糊或者使互连变得复杂。当不同的上下必须互相连接时，它们可能会相互重叠。

- BOUNDED CONTEXT之间的代码重用需要避免。功能和数据的集成必须要通过转换去实现；

**结论**
- 识别项目中起作用的每个模型，并定义其BOUNDED CONTEXT。这包括非面向对象子系统的隐含模型；
- 为每个BOUNDED CONTEXT命名，并把名称添至UBIQUITOUS LANGUAGE；
- 描述模型之间的联系点，明确所有通信需要的转换，并突出任何共享的内容；
- 先将当前的情况描绘出来，以后再做变更；

在每个BOUNDED CONTEXT中，都将有一种一致的UBIQUITOUS LANGUAGE的“方言”。我们需要包BOUNDED CONTEXT的名称添加到该方言中，只要通过明确CONTEXT就可以清楚地讨论任意设计部分的模型。

**BOUNDED CONTEXT之间的关系有很多，接下来的几节会介绍**。注意只需要描述所发现的关系，不要生搬硬套。过后再向更加标准的关系过渡。如果模型产生了分裂，而且关系很模糊，可以选择一种最接近的模型，向他靠拢。最重要的是画出一个清晰的CONTEXT MAP。但不要因为修复必要的问题而重组整个结构，只需要修改明显的矛盾。

在更改实际上完成以前，不要先修改CONTEXT MAP。

例子：运输应用程序中的两个CONTEXT
创建一个用于转换的对象，两个团队一起维护。设计应易于单元测试。与其他CONTEXT和谐共存的一个秘诀就是拥有有效的接口测试集

###### 1.3.1 测试CONTEXT的边界
对各个BOUNDED CONTEXT的联系点侧测试特别重要。可以解决转换时所存在的一些细微问题以及弥补边界沟通上存在的不足。测试充当了早期报警系统。

###### 1.3.2 CONTEXT MAP的组织和文档化
两个重点：
- BOUNDED CONTEXT应该有名称，以便可以讨论，需要添加到团队的UBIQUITOUS LANGUAGE中；
- 每个人都要知道边界在哪里，而且能够分辨出任何代码段的CONTEXT，或任何情况的CONTEXT；

#### 1.4 BOUNDED CONTEXT之间的关系
把模型连接到一起后，就能把整个企业笼括在内，可以成功地组织开发工作设定目标，为描述现有组织提供术语。
现有关系可能与这些模式中的某一种很接近——可能是由于巧合，也可能是有意设计的——这个情况下可以使用这个模式的术语来描述关系，但差异之处应该引起重视。随着每次小的设计修改，关系会与所选定的模式越来越接近。

- 如果团队需要为不同的用户群体提供服务，或者团队的协调能力有限，可能需要采用SHARED KERNEL或CUSTOMER\SUPPLIER关系。
- 有时研究需求之后可能发现集成并不重要，而系统最好采用SEPARATE WAY。
- 大多数项目需要与遗留系统或外部系统进行一定程度的集成，这需要OPEN HOST SERVICE或ANTICORRUPTION LAYER

#### 1.5 模式：SHARED KERNEL
> 定义单独的BOUNDED CONTEXT，并组织多个团队。用于减少重复，不是消除

问题：
持续集成收到局限。
- 比如团队技能水平或行政组织影响，又或者有一个庞大笨拙的团队。
- 不同的团队开发一些紧密相关的应用程序，团队之间不进行协调，即使短时间内能够取得快速进展，但开发出的产品可能无法结合在一起。最后不得不耗费大量精力在转换层上，并频繁改动。

**结论**
从领域模型中选出两个团队都同意共享的一个子集。当然，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据库设计的子集。这部分明确共享的内容有特殊地位，一个团队在没与另一个团队商量的情况下不应擅自更改。集成的频率比CONTINUOUS INTEGRATION低，集成的时候两个团队都要运行测试。

SHARED KERNEL通常是CORE DOMAIN，或是一组GENERIC SUBDOMAIN。可以是两个团队都需要的任何一部分模型。

#### 1.6 模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM
> 关键因素：关系必须是客户与供应商的关系，其中客户的需求是至关重要的；必须有自动测试套件，使上游团队在修改代码不必担心破坏下游团队产生副作用。

问题：
一个子系统主要服务于另一个子系统：“下游”组件执行分析或其他功能，这些功能向“上游”组件反馈的信息非常少，依赖是单向的。两个子系统通常服务于完全不同的用户群，执行任务也不同，在这种情况下使用不同的模型会很有帮助。

上下游自然是分隔到两个BOUNDED CONTEXT中。复杂点：如果下游团队对变更具有否决权，或请求变更的程序太复杂，那么上游的开发自由度就受到限制。由于担心破坏下游系统，上游团队甚至会受到抑制。同时，上游团队掌握优先权，下游团队有时也会无能为力。

**结论**
两个团队之间建立一种明确的客户/供应商关系。在计划会议中，下游团队相当于上游团队的客户。根据下游团队的需求来协商需要执行的任务并为这些任务做预算，以便每个人都知道双方的约定和进度。两个团队共同开发自动化验收测试，用来验证预期的接口。把这些测试添加到上游团队的测试套件中，以便作为其持续集成的一部分来运行。

自动化验收测试是这种客户关系的一个重要部分。

#### 1.7 模式：CONFORMIST
> 这个模式类似SHARED KERNEL，都有一个重叠的区域，在这个区域内的模型都是相同的。区别在于决策和开发过程不同。SHARED KERNEL是两个高度协调的团队之间合作。而这个是与一个对合作不感兴趣的团队进行集成。
> 具有上下游关系的团队不归同一个管理者指挥时，如果上游团队没有动力来满足下游团队的需求，那么下游团队也无能为力。

- 可以完全放弃上游 —— 走向SEPARATE WAY的道路；
- 上游的设计很难用，下游需要开发自己的模型，需要承担起开发转换层的全部责任 —— 走向ANTICORRUPTION LAYER
- 上游设计还好，风格也兼容，那么直接跟随 —— CONFORMIST

使用一个很大接口的现成组件时，一般应该遵循组件的隐含模型，可以使用一些适配器进行一点点格式转换，但模型一定要保持相同，否则就该质疑使用该组件是否正确。如果确实能够提供价值，说明设计中已经消化吸收了一些知识，比自己的理解要深入。遵从组件的领导，可以被带到更好更贴合的设计中。

**结论**
严格遵从上游团队的模型，可以消除BOUNDED CONTEXT之间转换的复杂性。尽管会限制下游设计人员的风格，可能会得不到理想的应用程序模型，但可以极大简化集成。好可以与供应商团队共享UBIQUITOUS LANGUAGE。供应商团队处于统治地位，使用可以使沟通变得容易。

#### 1.8 模式：ANTICORRUPTION LAYER
![1](DDD-11.png)
> 当把参与集成的BOUNDED CONTEXT设计完善并且团队相互合作时，转换层可能很简单，但当边界侧发生渗透时，转换层就承担起更多的防护职责。他是在不同模型和协议之间转换概念对象和操作的机制。**概念模型差别是使用此模型的动机。**

当正在构建的新系统与另一个系统接口很大时，为了克服连接两个模型带来的困难，新模型所表达的意图可能会完全改变，最终导致被修改得像另一个系统的模型。集成遗留系统有很大的价值，有时还是绝对必要的。

要把外部系统的数据类型转换为自己系统的数据类型，但是外部系统肯定不会使用相同的概念领域模型。我们需要在不同模型的关联部分之间建立转换机制，这样模型就不会被未经笑话的外来模型元素所破坏。

I**结论**
创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关功能。这个层通过另一个系统现有接口与其进行对话，而只需对哪个系统作出很少修改，甚至无需修改。在内部，这个层在两个模型之间进行必要的双向转换。

###### 1.8.1 设计ANTICORRUPTION LAYER的接口
公共接口通常是一组SERVICE形式出现，但偶尔也会采用ENTITY的形式。这层使我们能够重新对外部系统的行为进行抽象，使外部按照与我们模型一致的方式把服务和信息提供出来。把外部系统表示为一个单独的组件可能没有意义，最好使用多个SERVICE（或ENTITY），每个都使用我们的模型来履行一致的职责。

###### 1.8.2 实现ANTICORRUPTION LAYER
对ANTICORRUPTION LAYER进行组织的一种方式是把他实现为FACADE、ADAPTER和转换器的组合，外加两个系统之间进行对话所需的通信和传输机制。

FACADE，是子系统可供替换的接口。当从一个模型转换到另一个模型的时候，可以同时处理那些难于沟通的子系统接口。他简化了客户访问，使子系统更易于使用。他应该严格按照另一个系统的模型来编写。否则会导致转换职责蔓延到多个对象中，加重负担，甚至创建出另一个预料之外的模型。

ADAPTER，是包装器，允许客户使用另外一种协议，可以是行为实现者不理解的协议。当客户向适配器发送一条消息时，ADAPTER把消息转换为一条在语义上等同的消息，并将其发送给被适配者。

转换器，概念对象或数据的实际转换是完全不同的复杂任务，可以用一个单独的对象来承担。

ANTICORRUPTION LAYER可以是双向的：其他系统可能需要向我们的子系统提交某种请求或者把某个通知给我们的系统

#### 1.9 模式：SEPARATE WAY
> 两组功能之间并非必不可少，二者完全可以彼此独立

集成总是代价高昂，有时获益很小。集成会迫使我们作出一些折中。仅仅是因为特性在用例中相关，并不意味着他们必须集成到一起。

**结论**
声明一个与其他上下文毫无关联的BOUNDED CONTEXT，使开发人员能够在这个小范围内找到简单、专用的解决方案。

#### 1.10 模式：OPEN HOST SERVICE
> 子系统必须与大量其他系统进行集成时，为每个集成都定制一个转换层可能会减慢团队的工作速度。需要维护的东西会越来越多，而且修改的时候担心的事情也会越来越多。

大量与其他系统集成，意味着是一项基础设施了。可以描述为一组SERVICE，满足其他子系统的公共需求。

**结论**
定义一个协议，把我们的子系统作为一组SERVICE供其他系统访问。开发这个协议，以便所有需要与你子系统集成的人都可以使用它。当有新的集成需求时，就增强并扩展这个协议。但个别团队的特殊需求除外。满足这种特殊需求的方法是使用一次性的转换器来扩充协议，以便使共享协议简单且内聚。

其他团队必须学习HOST团队所使用的专用术语

#### 1.11 模式：PUBLISHED LANGUAGE
> 两个BOUNDED CONTEXT之间的模型转换需要一种公共语言。

问题：
- 两个领域模型必须共存而且必须交换信息时，转换过程本身就可能很复杂，很难文档化和理解；
- 不同的业务之间需要交换信息，让一个业务采用另一个业务的领域模型是不现实的；
- 尽管把一个应用程序的模型用作通信媒介，那么它必须非常稳定，用以支持通信职责，不能满足新需求而自由修改了；

**结论**
把一个良好文档化的、能够表达出所需领域信息的共享语言作为通信媒介，必要时在其他信息与该语言之间进行转换。

#### 1.12 大象的统一
盲人根据自己触摸到的部位来扩展自身的认知。
第一步将各部分模型集成成整体只需要弄清楚各个部分如何相连就够了。如果两个模型描述同一部分，两个人之间就会产生矛盾的认知，事实上需要一个新的抽象统一起来。
第二部去掉各个模型中偶然或不正确的方面，并创建新的概念。尽可能精简。

承认多个相互冲突的领域模型实际上正是面对显示的做法，通过明确每个模型都适用的上下文，可以维护每个模型的完整性，并清楚地看到要在两个模型之间创建的任何特殊接口的含义。

#### 1.13 选择你的模型上下文策略
> 绘制出CONTEXT MAP后，可以开始有意识地选择CONTEXT的边界和关系，下面给出指导

###### 1.13.1 团队决策或更高层决策
- 团队决定BOUNDED CONTEXT，以及他们之间的关系，至少要传达给整个团队并被每个人理解；
- 权衡团队独立工作的价值以及能产生丰富集成的价值，这两种价值的成本-效益作为决策的依据；
- 实践中，团队之间的行政关系决定了系统的集成方式。有技术优势的统一可能无法实现、管理层所要求的合并可能并不实用。不会总能得到想要的结果，但可以评估出这些决策的代价，反映给管理层，以便采取相应的措施减小代价；
- 从一个现实的CONTEXT MAP开始，根据实际的情况来选择改变；

###### 1.13.2 置身上下文中
开发时，我们对自己团队正在开发的部分感兴趣，其次是与我们交互的系统。
典型情况下，设计中的系统会划分为一到两个BOUNDED CONTEXT，主力在这些上下文中，可能会有另外一到两个起支持作用的CONTEXT。除此之外，就是这些CONTEXT与外部系统之间的关系。
知道自己的部分，能意识到超出该CONTEXT的应用边界。

###### 1.13.3 转换边界
> 画出边界时需要做权衡，在不同的BOUNDED CONTEXT之间进行深度功能集成是不切实际的。在一个模型中，只有能够严格按照另一个模型来表述的部分才能进行集成
首选较大的BOUNDED CONTEXT
- 一个统一的模型处理更多的任务时，用户任务之间流动更流畅；
- 一个内聚模型比两个不同模型再加他们之间的映射更容易理解；
- 两个模型转换可能很困难甚至不可能；
- 可以共同使用UBIQUITOUS LANGUAGE；

首选较小的BOUNDED CONTEXT
- 开发人员之间的开销较少；
- 团队、代码规模较小，CONTINUOUS INTEGRATION更容易了；
- 较大的上下文要求更加通用的抽象模型，而掌握所需技巧的人员会出现短缺；
- 不同的模型可以满足特殊需求，或者是能把一些特殊用户群的专门术语和UBIQUITOUS LANGUAGE的专门术语包括进来；

###### 1.13.4 接受那些我们无法更改的事物：描述外部系统
> 一些子系统不在开发中系统的任何BOUNDED CONTEXT，比如无法立即淘汰的大型遗留系统和那些提供所需服务的外部系统。识别，隔离它。

我们会轻易的认为这些系统构成了自己的BOUNED CONTEXT，但大多数外部系统只是勉强满足定义。
定义BOUNDED CONTEXT目的是把模型统一在特定边界内。集成时仔细检查，小心语义矛盾。

###### 1.13.5 与外部系统的关系
三种。
不需要集成，要真正确定不需要集成，SEPARATE WAY，只为用户提供对两个系统的简单访问，尽可能为项目减轻负担。
集成很重要，CONFORMIST，对创新的选择会受到限制，对一个大的系统进行外围扩展时，这个系统还是主系统，继续使用遗留模型就会很合适。约束自己只能扩展现有模型，不能修改。
当设计的功能不仅仅是扩展，而且与另一个系统接口很小，或者另一个系统设计很糟糕，我们会希望使用自己的BOUNDED CONTEXT，这时需要ANTICORRUPTION LAYER。

###### 1.13.6 设计中的系统
> 一个BOUNDED CONTEXT对应一个团队。一个团队也可以维护多个BOUNDED CONTEXT，但多个团队在一个上下文工作却是比较难的。
每个BOUNDED CONTEXT中应用CONTINUOUS INTEGRATION，但应该有几个上下文，各个上下文的关系是什么？
随着团队扩大，CONTINUOUS INTEGRATION会开始困难，可以采用SHARED KERNEL模式，把几组相对独立的功能划分到不同的BOUNDED CONTEXT中，使得每个BOUNDED CONTEXT中工作的人员少于10人。如果有两个上下文之间的所有依赖都是单向的，可以建成CUSTOMER/SUPPLIER DEVELOPMENT TEAM。
你可能会意识到两个团队的思想截然不同，导致建模工作总是相互矛盾，这种矛盾的原因是无法改变或不想改变的，可以采用SEPARATE WAY模式。在需要集成的地方共同维护一个转换层，把它作为CONTINUOUS INTEGRATION的点

###### 1.13.7 用不同模型满足特殊需要
> 同一业务的不同小组常常有各自的专用术语，而且可能各不相同，这些本地术语是非常精确的，想要实行标准化的企业级术语，需要大量培训和分析，即便如此，新术语也不会有原来的精确的术语好用。

通过不同的BOUNDED CONTEXT来满足这些特殊需求，除了转换层的CONTINUOUS INTEGRATION以外，让模型采用SEPARATE WAY模式。UBIQUITOUS LANGUAGE的不同专用术语将围绕这些模型。如果两种专用术语有很多重叠，SHARED KERNEL就可以满足特殊化要求，并发转换成本减至最小。
当不需要集成或者集成相对有限，可以继续使用已经习惯的术语，以免破坏模型。
为了满足特殊的需要，需要对系统这一部分进行多大的定制？最重要的是，这个用户群的专门术语有多大的价值。我们必须在团队独立操作的价值与转换的风险之间作出权衡，并留心合理地处理一些没有价值的术语变化。
有时会出现深层次模型，把不同语言统一起来，并满足双方的要求，只有经过大量开发工作和知识消化之后，深层次模型才会在生命周期后期出现。

###### 1.13.8 部署
> BOUNDED CONTEXT策略的选择将影响部署

例如CUSTOMER/SUPPLIER TEAM部署时，他们要相互协调发布。
有些版本需要进行代码和数据转移，好的做法是把CONTEXT之间的转换层放在同一个进程中。当数据迁移可能很花时间或者分布式系统无法同步更新，即使是单一BOUNDED CONTEXT中的组件部署也是很困难的，这回导致代码和数据有两个版本共存。
由于部署环境和技术存在不同，有很多技术因素需要考虑。但BOUNDED CONTEXT关系可以指出重点问题，转换接口已经被标出。
绘制CONTEXT边界时应该反映出部署计划的可能性。

###### 1.13.9 权衡
![1](DDD-12.png)
通过总结这些指导原则可知有很多统一集成模型的策略。一般来说我们需要在无缝功能集成的益处和额外协调和沟通工作之间作出权衡，还要在更独立的操作与更流畅的沟通之间作出权衡。更积极的统一需要对有关子系统的设计有更多控制。

###### 1.13.10 当项目正在进行时
大多数情况下我们是改进一个正在开发的项目。第一步是根据当前的状况来定义BOUNDED CONTEXT。为了有效定义上下文，CONTEXT MAP必须反映出团队的实际工作，而不是反映那个通过遵守以上表述的指导原则而得出的理想组织。
描述了真实的BOUNDED CONTEXT以及关系后，围绕当前组织结构来加强团队的工作。在CONTEXT中加强CONTINUOUS INTEGRATION。把分散的转换代码重构到ANTICORRUPTION LAYER。命名现有的BOUNDED CONTEXT，并确保处于项目的UBIQUITOUS LANGUAGE。
现在可以开始考虑修改边界和他们的关系了。
下节讨论修改CONTEXT的边界。

#### 1.14 转换
> 通常我们必须改变最初有关边界及BOUNDED CONTEXT之间关系的决策。分割很容易，但合并或者改变他们之间的关系却很难。转换往往很大，无法再一次重构中完成，甚至无法在一次项目迭代中完成。将转换划分为一系列简单的步骤（只是指导原则）

合并动机很多：翻译开销高，重复现象明显

###### 1.14.1 合并CONTEXT：SEPARATE WAY -> SHARED KERNEL
> 即使最终目标是完全合并成一个采用CONTINUOUS INTEGRATION的CONTEXT也应该先过渡到SHARED KERNEL
> SHARED KERNEL的有点多是它具有CONTINUOUS INTEGRATION的部分优势，同时保留了SEPARATE WAY的一些优点

1. 评估出事状况。在同一两个CONTEXT之前，一定要确信他们确实统一；
2. 建立合并过程，需要决定代码的共享方式以及模块应该采用哪种命名约定，SHARED KERNEL每周至少集成一次，而且要有测试套件；
3. 选择小的子领域开始，它应该是两个CONTEXT中重复出现的子领域，但不是CORE DOMAIN的一部分。最初合并主要是为了建立合并过程，先选择一些简单且相对通用或不重要的部分。坚持已存在的集成和转换。选择经过转换的部分，其优势在于一开始就有用于验证的转换机制，此外还可以简化转换层；

此时我们有两个对应相同子领域的模型。有三种合并方法，1）可以选择一个模型，并重构另一个，使之与第一个兼容。2）从整体上作出这个决策，把目标设置为系统性地替换一个CONTEXT模型，并保持被开发模型的内聚性。也可以一次选择一部分，到最后两个模型可能会两全其美。3）找到一个更为深刻的模型，承担两个模型的职责。

4. 两个团队选出2～4位开发人员组成小组，由他们来给子领域开发一个共享的模型，不管模型是如何得出的，他的内容必须详尽。难点：找出同义词和映射那些尚未被翻译的术语。这个联合团队要为模型开发一个基本的测试集；
5. 两个团队的开发人员一起负责实现模型（或修改共享的现有代码）、确定各种细节并使模型开始工作。如果开发人员在模型中遇到了问题，从第3步重新组织团队，并进行必要的概念修订工作；
6. 每个团队开发人员都承担新的SHARED KERNEL集成的任务；
7. 清除不再需要的翻译；

这时会得到一个非常小的SHARED KERNEL，并且有一个过程来维护。在后续的项目迭代中，重复3～7步来共享更多内容。

###### 1.14.2 合并CONTEXT：SHARED KERNEL -> CONTINUOUS INTEGRATION
> 如果SHARED KERNEL扩大，你可能会向完全统一BOUNDED CONTEXT。这不只是解决模型差异的问题，你将改变团队的结构，最终改变人们所使用的语言。

这个从人员和团队的准备开始
1. 确保每个团队都已经建立了CONTINUOUS INTEGRATION所欲的所有过程（共享代码所有权、频繁集成）。两个团队协商集成步骤，以便所有人都以同一步调工作。
2. 团队成员在团队之间流动。这样可以形成一大批同时理解两个模型的人员，并且可以把两个团队的人员联系起来；
3. 澄清每个模型的精髓；
4. 现在，团队可以把CORE DOMAIN合并到SHARED KERNEL中。可能需要多次迭代，有时需要在新共享的部分与尚未共享的部分之间使用临时的转换层。一旦进入到合并CORE DOMAIN的过程中，最好能快速完成。这是一个开销高且易出错的阶段，尽可能缩短时间，要优先新的开发任务；
5. 随着SHARED KERNEL的增长集成频率提高到每天一次，最后实现CONTINUOUS INTEGRATION；
6. 当SHARED KERNEL逐渐把先前两个BOUNDED CONTEXT所有内容都包括进来的时候，你要么形成了一个大团队，要么形成了两个较小的团队，这两个较小的团队共享一个CONTINUOUS INTEGRATION的代码库，而且团队成员可以经常在两个团队之间来回流动；

#### 1.14.3 逐步淘汰遗留系统
> 老系统与业务及其他系统紧密交织在一起，因此淘汰他们可能需要很多年，但不需要一次把所有东西都淘汰掉。

一种常见的情况：用一系列更现代的系统来补充业务中每天都在使用的老系统，新系统通过一个ANTICORRUPTION LAYER与老系统进行通信。
首先要执行的步骤是确定测试策略。应该为新系统中的新功能编写自动的单元测试，但逐步淘汰系统还有一些特殊的测试需求。一些组织在某段时间会同时运行新旧两个系统。

在任何一次迭代中
1. 确定遗留系统的那个功能可以在一个迭代中被添加到某个新系统中；
2. 确定需要在ANTICORRUPTION LAYER中添加的功能；
3. 实现；
4. 部署；

有时需要多次迭代才能编写一个与遗留系统某个功能等价的功能单元，这时在计划新的替代功能时仍以小规模的迭代为单元，最后一次性部署多次迭代。
进入运行阶段后：
5. 找出ANTICORRUPTION LAYER中不必要的部分，去掉他们；
6. 考虑删除遗留系统中目前未被使用的模块；

不断重复，遗留系统应该越来越少地参与业务。

#### 1.14.4 OPEN HOST SERVICE -> PUBLISHED LANGUAGE
> 随着需要访问的系统增多，维护负担不断增加，交互变得难以理解。需要通过PUBLISHED LANGUAGE来规范系统之间的关系

1. 如果有一种行业标准语言可用，尽可能评估并使用；
2. 如果没有标准语言或预先公开发布的语言，则完善作为HOST系统的CORE DOMAIN；
3. 使用CORE DOMAIN作为交换语言的基础，尽可能使用像XML这样的标准交互范式；
4. 向所有参与协作的各方发布新语言；
5. 如果设计新的系统架构，也要发布；
6. 为每个协作系统构建转换层；
7. 切换；

当加入更多的协作系统时，对整个系统的破坏已经减至最小了。
PUBLISHED LANGUAGE必须是稳定的。但是当继续进行重构时，仍然需要能够自由地更改HOST的模型。不要把交换语言和HOST的模型等同。保持他们密切的关系可以见效转换开销，而你的HOST可以采用CONFORMIST模式。但应该保留对转换层进行补充的权利。在成本-效益折中需要时，可以把这个权利分离出去。

## 2 精炼
> **精炼是把一堆混在一起的组件分开的过程。（目的）提取出重要内容。** 模型是知识的精炼。
> 关注核心问题。方法：LYAERED ARCHITECTURE可以把领域概念从技术逻辑中分离出来。但在大型系统中，即使领域被分离出来，它的复杂性也可能难以管理。

精炼过程所分离出来的副产品本身也很有价值，但精炼的主要动机是把最有价值的部分提取出来。这部分就是CORE DOMAIN。

战略精炼包括：
- 帮助所有团队成员掌握系统的总体设计以及各部分如何协调工作；
- 找到一个具有适度规模核心模型并把它添加到通用语言中，促进沟通；
- 指导重构；
- 专注于模型中最有价值的那部分；
- 指导外包、现成组件的使用以及任务委派；

![1](DDD-13.png)

#### 2.1 模式：CORE DOMAIN
> 大型系统中有非常多组成部分，但是要注意真正的业务资产——领域模型最精华的部分。

我们不可能对所有设计部分进行同等的精化，必须分出优先级。为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全根据这个核心来创建应用程序的功能。

不过高水平开发人员往往会把工作重心放在技术基础设施上，或者只是且解决那些不需要专门领域知识就能理解的领域问题。

在制定项目规划的时候，必须把资源分配给模型和设计中最关键的部分。在规划和开发期间每个人都必须识别和理解这些关键部分。这部分是应用程序的标志性部分，也是目标应用程序的核心诉求，构成了CORE DOMAIN。

**结论**
对模型进行提炼。找到CORE DOMAIN并提供一种易于区分的方法把它与起辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩CORE DOMAIN。
在CORE DOMAIN中努力开发能够确保实现系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的CORE。

它可以使决策变得容易。投入大量的工作使你的CORE鲜明突出，其他设计部分只需依照常规做得实用即可。如果某个设计部分需要保密以便保持竞争优势，那么它就是你的CORE DOAMIN。其他部分则没有必要隐藏起来。当必须在两个看起来都很有用的重构之间进行抉择时，应该首选对CORE DOMAIN影响最大的那个重构。

###### 2.1.1 选择核心
关注能够表示业务领域并解决业务问题的模型部分。
对CORE DOMAIN的选择取决于看问题的角度。一个应用程序的CORE DOMAIN在另一个应用程序中可能只是通用的支持组件。人们对CORE DOAMIN的认知也会随着迭代而发展。

###### 2.1.2 工作的分配
团队中，技术能力最强的任用往往缺乏丰富的领域知识，也更倾向于分派他们做支持组件，从而形成了一个恶性循环——知识的缺乏使他们远离能够学到领域知识的工作。
打破这种恶性循环是很重要的，方法是建立一支由开发人员和多位领域专家组成的联合团队，开发人员必须能力很强，能够长期稳定地工作并且对学习领域知识非常感兴趣。领域专家则要掌握深厚的业务知识。

从外部聘请短期的专业人员来设计CORE DOMAIN的关键环节通常是行不通的，因为团队需要累积领域知识，短期人员会造成知识流失。不过充当培训和知道角色的专家可能会有价值，可以帮助团队建立领域设计技巧，促成团队成员实用尚未掌握的高级设计原则。

自主开发的软件最大价值来自于对CORE DOMAIN的完全控制。一个设计良好的框架可能会提供满足你的专门实用需求的高水平抽象，可以节省开发那些更通用部分的时间，使我们更专注于CORE。如果它对我们的约束超过了限度，可能原因有：
- 正在失去一项重要的软件资产。应该让这些限制性的框架退出CORE DOMAIN；
- 框架处理的部分并不是你所认为的核心。此时应该重新划定CORE DOMAIN的边界，把真正标志性部分识别出来；
- 我们的CORE DOMAIN没有特殊需求。应该考虑采用风险更低的解决方案，如购买软件与我们的应用程序进行集成；

最终我们需要一支稳定工作的团队，不断累积和消化专业知识，将知识转换为一个丰富的模型。

#### 2.2 精炼的逐步提升
> 接下来会介绍各种精炼技术，在使用顺序基本没要求，对设计的改动却大不相同

各个技术的简介：
- DOMAIN VISION STATEMENT（领域愿景说明），只需很少投入，它传达了基本概念以及价值；
- HIGHLIGHTED CORE（突出核心）可以增进沟通，并指导决策制定，这也只需对设计进行很少的改动甚至无需改动；
- 更积极的精炼方法是通过重构和重新打包显示地分离出GENERIC SUBDOMAIN，单独进行处理；
- 在使用COHESIVE MECHANISM同时，也要保持设计的通用性、易懂性和柔性，这两个方面可以结合起来；
- 重新打包出SEGREGATED CORE（分离的核心），也可以使这个CORE清晰可见，并且促进将来在CORE模型上的工作；
- 最富雄心的精炼是ABSTRACT CORE（抽象内核），用纯粹的形式表示了最基本的概念和关系（这需要对模型进行全面的重新组织和重构）；

#### 2.3 模式：GENERIC SUBDOMAIN
> 这是充分利用外部设计专家的地方，因为专家不需要深入理解我们的领域。机密性问题不用过多关注。

模型中有部分除了增加复杂性以外没有捕捉或传递任何专门的知识。任何外来因素都会使CORE DOMAIN愈发的难以分辨和理解。模型中充斥这大量众所周知的一般原则。这些细节不是我们的主要关注点，而只是起到支持作用。不论多么通用的元素，他们对实现系统功能和充分表达模型都是极为重要的。

即使通用模型元素确实非常重要，整个领域模型仍然需要把系统中最有价值和最特别的方面突出出来，而且整个模型的组织应该尽可能把重点放到这部分上。

**结论**
识别出与项目意图无关的内聚子领域。把这些子领域的通用模型提取出来，放到单独的MODULE中。任何专用的东西都不应放在这些模块中。
分离出来以后，在继续开发的过程中，他们的优先级应低于CORE DOMAIN的优先级，不要分派核心人员来完成这些任务。可以考虑为这些GENERIC SUBDOMAIN使用现成的解决方案或“公开发布的模型”（PUBLISHED MODULE）

**可以找现成已经实现好的解决方案**
分析：
优：可以减少代码开发；维护负担转移到了外部；被多次使用，较为成熟；
缺：但是要评估和理解；无法保证正确性和稳定性；可能设计过于细致，比开发一个最小化的内部实现更大；可能引进一个与你项目完全不同的BOUNDED CONTEXT；会引入对平台、编译器版本的依赖等；

**公开发布的设计或模型**
如果领域中已经有了非常正式且严格的模型，那就使用它（比如会计、物理、医疗系统）。如果在一个公开发布的模式能够发现一个简化的子集，本身是一致的而且能够满足我们的要求，就不需要完全实现一个这样的模型。
分析：
优：比自己开发的模型更成熟，反映了很多人的深层知识；有随时可用的高质量文档；
缺：但是可能过于细致，超出了我们的需要，或者不符合我们的需要；

**外包出去**
自动测试在外包中可能起到重要作用。要求外包人员为他们交付的代码提供单元测试。为外包的组件详细说明甚至编写自动验收测试，助于确保质量、明确规格并使组件再集成变得顺利。
分析：
优：核心团队可以处理CORE DOMAIN；开发工作的增加不会使团队规模无限扩大，同时不会导致CORE DOMAIN知识的分散；强制团队采用面向接口的设计，有助于保持子领域的通用型，因为规格已经被传递到外部；
缺：但是仍需要核心团队花费时间在与外包人员商量接口、编码标准和其他重要方面；当把代码移交回团队时，团队需要耗费大量精力理解这些代码（也不会有专用子领域复杂）；代码质量高低取决于团队能力；

**内部实现**
分析：
优：易于集成；只开发自己需要的，不做多余工作；可临时把工作分包出去；
缺：需要承受后续的维护和培训负担；容易低谷开发这些软件所需的时间和成本；

###### 2.3.1 通用不等于可重用
不必开发成万能的模型，只需把业务所需的部分建模并实现即可。
尽管很少需要考虑设计的可重用行，但通用子领域的设计必须严格地限定在通用概念的范围之内。

###### 2.3.2 项目风险管理
敏捷过程通常要求通过尽早解决最具风险的任务来管理风险（如XP过程）。这种初步的系统通常用来检验某种技术架构，而且人们会试图建立一个外围系统，用来处理一些支持性的GENERIC DOMAIN，因为这些子领域通常更易于分析。
这可能会不利于风险管理。有些项目的技术风险更大，有些项目是领域建模的风险更大。

除非团队拥有精湛的技术并且对领域非常熟悉，否则第一个雏形系统应该以CORE DOMAIN的某个部分作为基础，不管有多么简单。相同的原则适用于任何把高风险的任务放到前面处理的过程。

接下来展示DOMAIN VISION STATEMENT和HIGHLIGHTED CORE用最少的投入通过补充文档来增进沟通、提高人们对核心的认识并使之把开发工作集中到CORE上来。

#### 2.4 模式：DOMAIN VISION STATEMENT
> 它指出了一个方向。从宽泛的角度对CORE DOMAIN进行说明。

项目开始时，模型通常不存在。但模型开发的需求是早就确定的重点。在后面的开发阶段，我们需要解释清楚系统的价值，但这并不需要深入地分析模型。此外，领域模型的关键方面可能跨越多个BOUNDED CONTEXT，而且从定义上看，无法将这些彼此不同的模型组织起来表面其共同的关注点。

最好的愿景说明会展示应用程序为组织带来的具体价值。一些愿景会把创建领域模型当作一项战略资产。DOMAIN VISION STATEMENT是模仿这类文档创建的，但它关注的重点是领域模型的本质。可以直接用领域愿景说明来知道资源分配、建模选择和团队成员的培训。

**结论**
写一份CORE DOMAIN的简短描述以及它将会创造的价值，也就是“价值主张”。不能将我们的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型是如何实现和均衡各方利益的。要精简、尽早写出，随着新的理解随时修改。

#### 2.5 模式：HIGHLIGHTED CORE
> 把模型一个特别部分连同它的实现一起区分出来，这只是对模型的一种反映，而不必是模型自身的一部分。任何使人们易于了解CORE DOMAIN的技术都可以采用。

经过领域愿景可以知道核心领域是由什么构成的，但CORE DOMAIN中到底包含那些元素，这要求CORE DOMAIN必须很容易被分辨出来。
对代码做重大结构性改动是识别CORE DOMAIN的理想方式，但这些改动往往不能在短期内完成。事实上，如果团队认识不够全面，这样重大代码修改是很难进行的。

用一些轻量级的解决方案来补充这些激进的技术手段。可能有一些约束使你无法从物理上分离出CORE，或者你可能是从已有代码开始工作的，而这些代码没有很好地区分出CORE，但你确实需要知道什么是CORE并建立共识，以便有效通过重构进行更好的精炼。通过仔细挑选几个图或文档，也能为团队提供思考的定位点和思考点。

###### 2.5.1 精炼文档
> 应当能被团队中非技术人员理解。是一个简单的切入点，描述并解释核心，给出进一步研究核心部分的理由。提供一个总体视图，指出各个部分是如何组合在一起的，并指导读者到相应的代码部分寻找更多细节。

创建单独的文档来描述和解释CORE DOMAIN。只是最核心概念对象的清单。可以是一组描述对象的图，显示他们之间的关系。可以是在抽象层次上通过事例描述基本交互。精炼文档并不是完备的设计文档。

**结论**
编写一个简短的文档，用于描述CORE DOMAIN以及CORE元素之间的主要交互过程。

风险：文档得不到维护；没人阅读；多个信息涞源，不能达到简化复杂性的目的。
控制这些风险最好就是保持绝对的精简，剔除不重要的细节，只关注核心抽象以及交互，这样文档老化速度就会减慢，因为这个层次的模型通常更稳定。

###### 2.5.2 标明CORE
面对一大堆模型、类图，依赖专业的分析师帮助，把体现出基本的、区别于其他系统概念的部分标志性出来，这些是我们真正需要处理的部分。

**结论**
把模型的主要在存储库中的CORE DOMAIN标记出来，不用特意去阐明其角色。使开发人员很容易就知道什么在核心内，什么在核心外。

###### 2.5.3 把精炼文档作为过程工具
把精炼文档作为一个指南。如果开发人员发现精炼文档本身需要修改以便与他们的代码或模型修改保持同步，那么这样的修改需要大家一起协商。这种修改要么是从根本上修改CORE DOAMIN元素或关系；要么是修改CORE DOMAIN的边界，把一些元素包含进来，或者把一些元素排除出去。模型的修改都必须传达到整个团队。

可以指示模型改变的重要程度。当模型或代码的修改影响到精炼文档时，需要与团队其他成员一起协商。当对精炼文档作出修改时，需要立即通知所有团队成员，把新版本文档分发出去。CORE外部的修改或精炼文档外部的细节修改则无需协商或通知，可以直接集成到系统中，其他成员在后续工作过程中自然会看到这些修改。这样开发人员就拥有了XP所建议的完全自治性。

接下来的模式着眼于从结构上修改模型和设计本身，目的是使CORE DOMAIN更明显，易于管理。

#### 2.6 模式：COHESIVE MECHANISM
封装机制是面向对象设计的基本原则，把复杂算法隐藏到方法中，为方法起一个一看就知道用途的名字，把做什么和如何做分开了。

问题：
但有时计算会变得非常复杂，使设计变得膨胀。机械性的如何做大量增加，把概念性的做什么完全掩盖了。为解决问题提供算法的大量方法掩盖了那些用于表达问题的方法。

这种方法的扩散是模型出问题的症状。需要重构得到更深层的理解，找到更适合解决问题的模型和设计元素。首先要寻找的解决方案是找到能使计算机制变得简单的模型。

**结论**
把概念上的COHESIVE MECHANISM分离到一个单独的轻量级框架中。要特别注意公式或那些有完备文档的算法。用INTENTION-REVEALING INTERFACE来暴露这个框架的功能。现在，领域中的其他元素就可以只专注与如何表达问题了，把解决方案的复杂细节（如何做）转移给了框架。

例子：
有一个非常详尽的组织结构图，可以表示一个人正在为谁工作，所属哪个分支部门，这个模型有一个接口，大部分问题类似于谁有权批准这件事或者这个部门谁能处理这样的问题。我们可以意识到大部分复杂性是来自于便利组织树的特定分支，这恰好是成熟的图系统能解决的问题，即遍历图所需的规则和算法组成。

###### 2.6.1 GENERIC SUBDOMAIN与COHESIVE MECHANISM的比较
> 模型提出问题，COHESIVE MECHANISM解决问题

动机都是为CORE DOMAIN减负。但二者承担的职责性质不同。
- GENERIC SUBDOMAIN是描述性的模型作为基础，它用这个模型表示团队会如何看到领域的某个方面，与CORE DOMAIN没什么区别，只是重要性和专门程度较低；
- COHESIVE MECHANISM不表示领域，目的是解决描述性模型所提出一些复杂计算问题；

###### 2.6.2 MECHANISM是CORE DOMAIN的一部分
非常专用的算法（非常高效的算法）机制就可以被认为是概念核心的一部分。

实用的重构在保留中间阶段的重要价值的同时还能够去除不必要的复杂性。

#### 2.7 通过精炼得到声名式风格
深层模型往往与相对应的柔性设计一起产生。柔性设计变得成熟的时候，就可以提供一组易于理解的元素，我们可以明确地把它们组合到一起来完成复杂的任务，或者表达复杂的信息，就像单词组成句子一样。此时，客户代码就可以采用声名式风格，而且更为精炼。

#### 2.8 模式：SEGREGATED CORE
> 对核心提高内聚

模型中元素有一部分术语CORE DOMAIN，另一部分起支持作用。核心元素可能与一般元素紧密耦合。CORE的概念内聚性不是很强，看上去也不明显。这种混乱性和耦合关系抑制了CORE。设计人员如果无法清晰看到最重要的关系，就会开发出脆弱的设计。

**结论**
对模型重构，把核心概念从支持性元素分离出来，增强CORE的内聚性，同时减少与其他代码的耦合。把所有通用元素或支持性元素提取到其他对象中，并把这些对象放到其他包中——即使会把一些紧密耦合的元素分开。

步骤：
1. 识别一个CORE子领域；
2. 把相关的类移到新的MODULE中，并根据与这些类有关的概念为模块命名；
3. 对代码进行重构，把那些不直接表示概念的数据和功能分离出来。把分离出来的元素放到其他包的类中。尽量把他们与概念上相关的任务放在一起。把注意力放在提炼CORE子领域上，并且使CORE子领域对其他包的引用变得更明显且易于理解；
4. 对新的SEGREGATED CORE MODULE进行重构，使其中的关系和交互变得简单，表达更清除，最大限度减少并澄清它与其他MODULE的关系；（持续进行的）
5. 对另一个CORE子领域重复这个过程，直到完成SEGREGATED CORE的工作；

###### 2.8.1 创建SEGREGATED CORE的代价
有时CORE分离出来会使那些紧密耦合的非CORE类的关系变得更晦涩，甚至更复杂，但CORE DOMAIN更清晰、易于处理，这是值得的。
有时会把一个内聚性很好的MODULE拆开，通过牺牲这种内聚性来换取CORE DOMAIN的内聚性，最有价值的都在这里。
另一个代价是分离CORE需要付出很大的工作量。我们要认识到，作出SEGREGATED CORE的决定时，有可能需要开发人员对整个系统作出修改。

###### 2.8.2 不断发展演变的团队决策
新的理解必须持续不断的在整个团队中共享，但个人不能单方面根据这些理解擅自采取行动，无论团队采用了什么样的决策过程，团队一致通过也好，由领导者下命令决定也好，决策过程都必须具有足够的敏捷性，可以反复纠正。

#### 2.9 模式：ABSTRACT CORE

问题：
即便是CORE DOMAIN模型也会包含太多的细节，以至于它很难表达出整体视图。

当不同MODULE的子领域之间有大量交互，要么需要在MODULE之间创建很多引用，这在很大程度抵消了划分模块的价值；要么就必须间接地实现这些交互，而后者会使模型变得晦涩难懂。
可以采用横向切割而不是纵向切割的方式。多态性允许我们忽略抽象类型实例的很多细节变化。如果MODULE之间的大部分交互都可以在多态接口这个层次上表达出来，那么就可以把这些类型重构到一个特定的CORE MODULE中。

这并不是寻找技术上的技巧。只有当领域中的基本概念能够用多态接口来表达时，这才是一种有价值的技术。这种情况下，把这些分散注意力的细节分离出来可以使MODULE解耦，同时精炼出一个更小、更内聚的CORE DOMAIN

**结论**
把模型中最基本的概念识别出来，并分离到不同的类、抽象类或接口中。设计这个抽象模型。使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的MODULE中，而专用的、详细的实现类则留在由子领域定义的MODULE。

它的抽象结果应该与精炼文档非常类似。

#### 2.10 深层模型精炼
精炼不仅限于从整体上把领域中的一些部分从CORE分离出来。他也意味着对子领域（特别是CORE DOMAIN）进行精炼，通过持续重构得到更深层的理解，从而向深层模型和柔性设计推进。精炼的目的是把模型设计的更明显，使我们可以用模型简单的把领域表示出来。深层模型把领域中最本质的方面精炼成一些简单的元素，使我们可以把这些元素组合起来解决应用程序的重要问题

尽管任何带来深层模型的突破都有价值，但只有CORE DOMAIN中的突破才能改变整个项目的轨道

#### 2.11 选择重构目标
如何入手
1. 如果采用哪儿不对重构哪儿，要管礤根源问题是否设计CORE DOMAIN或CORE与支持元素的关系。如果涉及，接受挑战，修复核心；
2. 当可以自然选择重构部分时，集中精力把CORE DOMAIN更好地提取出来，完善CORE的分离，并且把支持性的子领域提炼成通用子领域

## 3. 大型结构
