
# 目录

- [接口规范](#1)
- [Controller规范](#2)
- [AOP 统一异常处理](#3)
- [日志规范](#4)
- [异常处理](#5)

主要参考来源[晓风轻-程序员你为什么这么累](https://xwjie.github.io/rule/)

## [接口规范](#1)

- 所有接口（对外）都必须返回ResultBean/ResultPageBean（还需考虑接口应该返回什么内容作为出参，如：新增操作需要返回新增的对象）；
- 一开始就要考虑成功和失败二种场景；
- ResultBean只允许出现在controller，不允许到处传；
- 不要出现 map ，json 等复杂对象做为输入和输出；
- 不要出现 local ，messagesource 等和业务无关的参数；

## [Controller规范](#2)

- 返回统一的ResultBean/PageResultBean格式（Controller专用的，不允许往后传）
- Controller做参数格式的转换（即必须转成对象，才能传给Service使用）
- 入参必须与业务相关（一般情况不允许出现Request，Response这些对象）
- 不要自己打印日志，交由AOP打印日志

## [AOP 统一异常处理](#3)

AOP里面统一处理异常，包装成相同的对象ResultBean给前端。ResultBean组成：code, msg, result(泛型)
主要使用`@ControllerAdvice`, `@ExceptionHandler`注解，**异常要区分已知异常和未知异常**，其中未知的异常是我们重点关注的，可以进行特别通知处理。未知的为Exception处理；已知的可以自定义异常，用枚举类细分错误码。**重要的是：打出错误日志，尤其是未知的错误**

```Java
/**
 * 类GlobalExceptionHandler的实现描述：统一异常处理
 *
 * @author ronustine
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    private Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 未知异常
     * @return
     */
    @ExceptionHandler(Exception.class)
    @ResponseBody
    ResponseBean handleException(Exception e) {
        log.error("系统内部错误，响应系统内部错误，具体错误见下", e);
        return ResponseBean.builder().fail(SpErrorCodeEnum.ERROR_CORE_1000).build();
    }

    /**
     * 业务异常
     * @return
     */
    @ExceptionHandler(SpBusinessException.class)
    @ResponseBody
    ResponseBean handleBusinessException(BaseException e) {
        log.error("系统业务错误，响应错误内容：[{}]", e.getResultMsg());
        return ResponseBean.builder().fail(e.getResultCode(), e.getResultMsg()).build();
    }
}
```

## [日志规范](#3)

> 目的：能找到那个机器；能找到用户做了什么；可以确定通过日志可以看到整个流程。
建议：不要依赖debug，多依赖日志；开发完成应确认自己是否能看懂控制台的日志输出。

- nginx配置，返回头里保存是哪个机器（简单配置见下）；
- 使用log4j中MDC的类，通过Filter保存用户信息。具体：执行filterChain前先放置用户信息至MDC，执行后清理掉；
- 处理数据时带上数据量，可评测性能；
- 参数化信息，不要拼接。参数变量请用写成用{}填充：

```java
logger.debug("Processing trade with id:[{}] and symbol : [{}] ", id, symbol);
```

- 条件分支，把必须条件打印出来；
- 区分日志等级：ERROR 影响正常运行；warn 有容错机制请求的异常情况；info 业务状态变更，调用第三方的请求和返回参数；debug 可获取敏感信息，ID，主键等所有需要知道的信息；
- 开发时尽可能避免Debug，看日志分析问题（养成写日志的习惯），日志尽可能代替注释；
- 范例：

## [异常处理](#5)

> 重要：不要吃掉异常（catch完不打印错误栈，单纯输出一条日志或者什么都没有）；不要用try catch掩盖错误，实际上并没有处理，造成更加复杂的问题，有错就抛出来

- 开发组长定义好异常，异常继承RuntimeException。
- 不允许开发人员捕获异常。（异常上对开发人员就这点要求！异常都抛出到controller上用AOP处理）
- 后台（如队列等）异常一定要有通知机制，要第一时间知道异常。
- 少加空判断，加了空判断就要测试为空的场景