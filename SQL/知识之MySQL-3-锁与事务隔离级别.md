[TOC]

## AICD
> 一般都会用ACID来表达事务的特性。A、C、I、D分别代表“原子性”，“一致性”，“隔离性”和“持久性“.

这部分参考[数据库事务、隔离级别和锁](https://www.jianshu.com/p/cb97f76a92fd)
- Atomicity，原子性。对数据的修改,要么全都执行,要么全都不执行。
（表达的意思与常规语境不大一样。对于支持并发的语言，是指一组指令被执行不受其他指令的干扰，如CAS是原子的。但在AICD语境，这“不受干扰”其实是后面的隔离性。在AICD中，是指一组对数据库的改变，要么最终成功执行完成，要不就全部回滚。这要求数据库系统要实现某种回滚机制（MySQL的Undo log））
- Consistency，一致性。在事务完成前后，数据都是要在业务意义上是”正确的“。保证业务是否正确是要业务代码来最终保证的，数据库能做的非常有限。
- Isolation，隔离性。是指一组对数据库的并发修改互不影响。保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
（这个概念表面上看起来并不是能说得通：如果并发修改的是互不相关的数据，那么自然隔离性可以满足；如果并发修改的是相关联的，或者是同一份数据，就必然会相互影响。那么，此时可以做的就是区分哪个修改优先级更加高。高优先级覆盖低优先级的。但实际上并发修改不能讲清楚先来后到的，此时谁生效无法很好的定义。另外一种情况是“先读取，再基于读取结果对数据进行修改”的逻辑。比如先读库存，基于当前的值做计算。**这时保证隔离性的主要问题不在于隔离本身，而在于如果将读取作为对数据修改的前提条件，之后在数据进行修改的时候，读取的前提条件还是否满足。** 毕竟读取和写入是两个分开的指令，而在这两个指令中间可能夹杂其他事务对数据的修改。保持隔离性的一个简单做法是保证对关联数据的修改串行化，对应事务性数据库的“Serializable”隔离级别。保证串行化的一种方案是锁，通过锁定可以彻底避免竞争条件。但对性能影响很大，所以衍生出几种弱一些的隔离保证——read uncommitted, read committed, repeatable read. 此外MVCC能够解决一部分锁带来的问题）
- DURATION，持久性。是指对数据的修改，一旦完成，结果应当永远不丢失。
（在现实当中，一般通过持久性存储设备写入并刷新来保证数据的持久性。如果觉得一个节点不靠谱，可以增加多个副本一起来保证持久；可以在不同的地理位置的另一个数据中心做备份。）

综上，
- 支持未完成的数据修改回滚的机制，对应“原子性”；
- 力所能及的数据合法性检查，对应“一致性”；
- 保证数据并发的修改的规则，对应“隔离性”；
- 使用基于持久化存储（磁盘、SSD）的方式对数据进行存储，对应“持久性”；

## 并发事务带来的问题
- 更新丢失：两个或多个事务选择同一行，然后基于最初选定的值更新该行，由于每个事务都不知道其他事务的存在，就会出现最后的更新覆盖了由其他事务所做的更新；
- 脏读：A事务可以读到B事务已修改但未提交的内容。还在这个内容做了操作。如果B事务回滚，A读取的数据就是无效的；
- 不可重复读：一个事务内多次读取一行数据，但发现内容会不一样。即A读到了B已提交的修改；
- 幻读：事务A读取到了事务B提交的新增数据；

## 锁
> 是计算机协调多个进程或线程并发访问某一资源的机制。数据库中，除了传统的计算资源（CPU、RAM、I/O等）的争用以外，数据也是一种需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

#### 分类
- 性能上分乐观锁（版本比对实现）、悲观锁；
- 从对数据库操作的类型分，读锁和写锁（均为悲观锁）；
- 数据操作的粒度，表锁和行锁；

读锁是共享锁，针对同一份数据，多个读操作可以同时进行而不会相互影响。写锁是排它锁，当前写操作没有完成前，它会阻断其他写锁和读锁。

#### 表锁
每次操作会锁住整张表，开销小，加锁快；锁定粒度大，发生锁冲突的概率最高，并发度最低；
```sql
-- 手动增加表锁
lock table tabl1 read(write), table2 read(write);
-- 查看表上加过的锁
show open tables;
-- 删除表锁
unlock tables;
```

- 加读锁后session和其他session可以读该表，当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待；
- 加写锁后，当前seesion对该表的增删改查都没问题，其他session对该表所有操作被阻塞；

**结论**
- MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁；
- 读写互斥，读读共享；

#### 行锁
每次操作锁一行数据，开销大，加锁慢，会出现死锁；粒度最小，发生锁冲突的概率最低，并发度最高。
InnoDB与MyISAM的最大不同：前者支持事物、支持行级锁

#### 注意
1. 无索引行锁会升级为表锁
InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。

2. 锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：`select * from test_innodb_lock where a = 2 for update;` 这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交。

3. 行锁分析
通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：`show status like'innodb_row_lock%';`
对各个状态量的说明如下：
Innodb_row_lock_current_waits: 当前正在等待锁定的数量
Innodb_row_lock_time: 从系统启动到现在锁定总时间长度
Innodb_row_lock_time_avg: 每次等待所花平均时间
Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间
Innodb_row_lock_waits:系统启动后到现在总共等待的次数

对于这5个状态变量，比较重要的主要是：Innodb_row_lock_time_avg（等待平均时长）、Innodb_row_lock_waits （等待总次数）、Innodb_row_lock_time（等待总时长）
尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统 中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。

## 隔离级别
| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| - | - | - | - |
|读未提交| 可能 | 可能 | 可能 |
|读已提交| 不可能 | 可能 | 可能 |
|可重复读| 不可能 | 不可能 | 可能 |
|可串行化| 不可能 | 不可能 | 不可能 |
常看当前数据库的事务隔离级别: `show variables like 'tx_isolation';`
设置事务隔离级别：`set tx_isolation='REPEATABLE-READ';`

#### 不隔离
不同的事务可以对同一个数据并发随便修改：A事务修改了一半的结果B能看到；B改了一半的结果A也能看到；A、B反复修改同一个数据，彼此覆盖。
分两种：
- Dirty Read，脏读。即一个事务的没提交之前的修改被另外一个事务可以看到。
- Dirty Write，脏写。即一个事务的没提交之前的修改可以被另外一个事务的修改覆盖掉。

脏读在某些场景是可以被接受的，不做“读取-修改”，或者也看业务场景；
使用锁可以避免脏写。

#### 隔离
- Read Uncommitted：在当前开启事务的Session中，可以读到其他Session未提交的事务；
- Read Committed：在当前开启事务的Session中，可以读到其他Session已经提交的事务；
- Read Repeatable：在当前开始事务的Session中，会生成一个ReadView，保证即使数据被其他事务修改，在本Session中也不会变化；
- Serialized：锁表，串行化一个个事务执行，并发度极低；

#### 相关问题
1. MySQL默认级别是repeatable-read，能否解决幻读？
间隙锁可以满足：可以用间隙锁在Session_1下面执行update account set name = 'xxx' where id > 10 and id <=20;，则其他Session没法在这个范围所包含的 间隙里插入或修改任何数据。

#### MVVC原理
> 是对读做出的优化，可满足读已提交、可重复读的隔离级别。
> MVCC是"Multi-Version Concurrency Control"的缩写。对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这个版本一般用进行数据操作的事务ID(单调递增）来定义。

对于在MySQL中的实现，可以这么解释：
有一个Undo Log，每次开启事务时会生成事务ID：tx_id，做增删改会在B+树的子节点做出操作，保证B+树上是最新的数据，旧数据会标上tx_id —— 被哪个事务操作了，并链上最新的数据。每个事务中读取数据时，在Undo Log找出符合当前隔离级别的数据返回即可。如果是读已提交，那么会读最新已提交事务的数据；如果是可重复读，那么只会读当前事务的数据，不去管其他事务提交的。

**具体的解释**
当执行查询SQL时会生成一致性视图read-view，它是由所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，查询的数据结果要跟read-view做对比从而得到快照结果。
版本链比对规则：
1. 如果tx_id < min_id，这表明版本是已提交的事务生成的，这个数据是可见的；
2. 如果tx_id > max_id，表示版本是将来启动的事务生成的，肯定不可见；
3. 如果min_id < tx_id < max_id，分两种情况：a) 如果在未提交的数组中，不可见，如果是在自己的事务才可见；b) 如果不在未提交的数据中，表示这个版本是已经提交了版本的事务生成的，可见。
删除，可以认为是更新的特殊操作，会复制一份，将tx_id修改成删除操作的tx_id，并在该条信息的头信息的delete_flag标记为true，表示已被删除，并且不返回该数据结果。

依据上面的逻辑，可以知道读已提交是每次查询都生成新的read-view，可重复读是只在第一次查询生成新的read-view。