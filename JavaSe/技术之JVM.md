
数据类型
JavA虚拟机中分为两类：基本类型、引用类型。
基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址）

堆与栈
栈是运行时关键，堆是存储的单位。即栈是解决程序运行的问题，或处理数据的逻辑；堆则是解决数据存储
线程：一个线程会对应一个线程栈，不同的逻辑需要不同的栈。堆则是共享的。栈是运行单位，因此里面存储的信息都跟当前线程有关，包括局部变量、程序运行状态、方法值返回等；堆指负责存储数据。
为什么要分开堆和栈呢？
一、软件设计角度，栈代表逻辑，堆代表数据。
二、多个线程可访问同一个对象。如共享常量和缓存可被所有栈访问，节省空间。
三、栈需要保存系统运行的上下文，地址段的划分。栈只能向上增长，限制存储内容。堆可动态增长，栈只需引用堆。
四、面向对象是堆与栈的结合。接近自然的思考方式，对象的属性是数据，存储在堆中；对象的行为（方法）是运行逻辑。
Java中main是栈的起始点，也是程序的起始点。
堆存什么，栈存什么？
堆中是对象，栈中是基本数据类型和堆中对象的引用值。堆中对象的大小是动态变化的。但是在栈中一个对应着堆中对象的引用只占4btye。
为什么不把基本类型放堆中？
基本类型只占1~8字节，长度固定，栈可以满足。放入堆中会浪费空间。
到了这里，最容易引出的问题就是Java中传值到底传的是值还是引用？
首先明确，Java没有指针，Java的引用与C的指针也不一样；程序都是在栈中执行的，所以传递的时候不会传对象本身进入栈。在运行栈中，基本类型和引用类型的处理都是一样的——传值。所以当传引用的方法调用实际上是传引用值。
再确切的说：站在栈中的程序的角度来看，传基本类型时，值是拷贝的，只要不返回值，就不会被修改。传引用类型的时候，程序获得的是引用的值，程序在解析这个引用值时会根据引用值中标注对象的地址的信息去堆中找到那一个对象，再操作对象的数据，所以就算不返回值时，对象的值也会被修改。
栈是程序运行最根本的东西，程序可以没有堆，但是要有栈。堆只是供多个栈使用的共享内存。这也使得Java的垃圾回收机制成为可能。站的大小通过-Xss来设置。

Java对象的大小
基本数据类型的大小是固定的，不讨论。对象则是靠具体情况。Java中，空的Object为8 byte：Object o = new Object()。这个o占的空间为4 byte + 8 byte，4 byte是栈中引用的大小。由于所有的Java非基本类型的对象都是默认继承Object，因此都会大于8 byte。


Class NewObject {
int count;
boolean flag;
Object ob;
}
如上，大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。
因为这种包装类型已经成为对象了，因此需要把他们作为对象来看待。包装类型的大小至少是12byte（声明一个空Object至少需要的空间），而且12byte没有包含任何有效信息，同时，因为Java对象大小是8的整数倍，因此一个基本类型包装类的大小至少是16byte。它是使用基本类型的N倍（N>2）。在JDK5.0以后，因为加入了自动类型装换，因此，Java虚拟机会在存储方面进行相应的优化。

引用类型
强引用、软引用、弱引用、虚引用
强引用：一般声明对象时虚拟机产生，垃圾回收时需严格判断，强引用时不允许回收
软引用：一般作为缓存使用。与强引用区别是：虚拟机根据当前系统剩余内存来决定是否回收软引用
弱引用：与软引用类似，都是作为缓存使用。与软引用区别是：垃圾回收时一定会回收掉，生命周期只有一个垃圾回收周期
强引用不用说，我们系统一般在使用时都是用的强引用。而“软引用”和“弱引用”比较少见。他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。因而，他们常见的是被使用在桌面应用系统的缓存。