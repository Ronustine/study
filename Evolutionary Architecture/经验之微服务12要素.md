### **12-factors**

> 如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。
12-Factor 为构建如下的 SaaS 应用提供了方法论：

- 使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。
- 和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。
- 适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。
- 将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。
- 可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。

#### 1. 基准代码

> **一份基准代码（Codebase），多份部署（deploy）。** 基准代码和应用之间总是保持一一对应的关系：

- 一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。
- 多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。

#### 2. 依赖

> **显式声明依赖关系（ dependency ），不会隐式依赖系统级的类库。**

反例：
ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。

#### 3. 配置

> **在环境中存储配置，推荐将应用的配置存储于 环境变量 中（ env vars, env ）。**

#### 4. 后端服务

> **把后端服务(backing services)当作附加资源，应用不会区别对待本地或第三方服务。** 后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）

#### 5. 构建，发布，运行

> **严格分离构建和运行**

<u>基准代码</u> 转化为一份部署(非开发环境)需要以下三个阶段：

- *构建阶段* 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 <u>依赖项</u>，编译成二进制文件和资源文件。
- *发布阶段* 会将构建的结果和当前部署所需 <u>配置</u> 相结合，并能够立刻在运行环境中投入使用。
- *运行阶段* （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 <u>进程</u>。

#### 6. 进程

> **以一个或多个无状态进程运行应用** 且 无共。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

#### 7. 端口绑定

> **通过端口绑定(Port binding)来提供服务**  应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。
> 端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。

#### 8. 并发

> **通过进程模型进行扩展，** 进程是一等公民。主要借鉴于 unix 守护进程模型。
但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。
12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 *进程构成*
12-Factor 应用的进程 **不需要守护进程** 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。

#### 9. 易处理

> **快速启动和优雅终止可最大化健壮性。**

- 12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。
- 进程应当追求 **最小启动时间**。
- 一旦接收 终止信号（SIGTERM） 就会<u>优雅的终止</u>。
- 进程还应当在面对<u>突然死亡时保持健壮</u>。

<u>优雅的终止：</u>
**就网络进程而言**，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。
**对于 worker 进程来说**，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。

<u>保持健壮：</u>
例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论

#### 10. 开发环境与线上环境等价

> **尽可能的保持开发，预发布，线上环境相同，12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。开发人员应该反对在不同环境间使用不同的后端服务**

实际上可能出现差异：

- 时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。
- 人员差异： 开发人员编写代码，运维人员部署代码。
- 工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。

缩小差异：

- 缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。
- 缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。
- 缩小工具差异：尽量保证开发环境以及线上环境的一致性。

不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。

#### 11. 日志

> **把日志当作事件流，应用本身从不考虑存储自己的输出流**

日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。
日志应该是 **事件流** 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。
这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：

- 找出过去一段时间特殊的事件。
- 图形化一个大规模的趋势，比如每分钟的请求量。
- 根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。

#### 12. 管理进程

> **后台管理任务当作一次性进程运行**